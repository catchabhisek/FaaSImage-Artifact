commit dba2fca875d147341ef144ce5055f489a1eabe13
Author: catchabhisek <catchdevabi@gmail.com>
Date:   Wed Jan 31 15:05:34 2024 +0530

    changes for characterization

diff --git a/analysis_bottleneck.md b/analysis_bottleneck.md
new file mode 100644
index 0000000000..5c5f2e86b3
--- /dev/null
+++ b/analysis_bottleneck.md
@@ -0,0 +1,79 @@
+Analysis
+
+Hunch: The image is the culprit in the snapshot process. Let us dig on the image handler of Docker.
+
+
+
+Detailed explanation:
+"github.com/containerd/containerd/log"
+log.L.Errorf("FAAS: FAAS: FAAS \n")
+
+Bottleneck-I:
+FAAS: The container checkpoint task took 1.296964045s seconds 
+
+Starting point: vendor/github.com/containerd/containerd/task.go in function Checkpoint()
+'''
+	index := v1.Index{
+		Versioned: is.Versioned{
+			SchemaVersion: 2,
+		},
+		Annotations: make(map[string]string),
+	}
+
+	if err := t.checkpointTask(ctx, &index, request); err != nil {
+		return nil, err
+	}
+'''
+The checkpoint operation takes about 200 msec
+
+FAASCONT: The container checkpoint create diff and write content in 659.375914ms seconds 
+Starting point: containerd/services/tasks/local.go
+	// do not commit checkpoint image if checkpoint ImagePath is passed,
+	// return if checkpointImageExists is false
+	if !checkpointImageExists {
+		return &api.CheckpointTaskResponse{}, nil
+	}
+
+	start = time.Now()
+
+	// write checkpoint to the content store
+	tar := archive.Diff(ctx, "", image)
+	cp, err := l.writeContent(ctx, images.MediaTypeContainerd1Checkpoint, image, tar)
+	// close tar first after write
+	if err := tar.Close(); err != nil {
+		return nil, err
+	}
+	if err != nil {
+		return nil, err
+	}
+Explanation: 
+Diff returns a tar stream of the computed filesystem difference between the provided directories. Produces a tar using OCI style file markers for deletions. Deleted files will be prepended with the prefix ".wh.". This style is based off AUFS whiteouts. (See https://github.com/opencontainers/image-spec/blob/main/layer.md)
+
+
+FAASCONT: The container checkpoint write container spec in 532.603713ms seconds
+Starting point: containerd/services/tasks/local.go
+	// write the config to the content store
+	data, err := container.Spec.Marshal()
+	if err != nil {
+		return nil, err
+	}
+	spec := bytes.NewReader(data)
+	specD, err := l.writeContent(ctx, images.MediaTypeContainerd1CheckpointConfig, filepath.Join(image, "spec"), spec)
+	if err != nil {
+		return nil, errdefs.ToGRPC(err)
+	}
+Explanation: 
+
+
+
+Bottleneck-II: 
+FAAS: The container write index took 1.041085652s seconds
+
+Starting point: vendor/github.com/containerd/containerd/task.go in function Checkpoint()
+'''
+	start = time.Now()
+	desc, err := t.writeIndex(ctx, &index)
+	if err != nil {
+		return nil, err
+	}
+'''
diff --git a/api/server/router/image/image_routes.go b/api/server/router/image/image_routes.go
index f34fe56073..375a587108 100644
--- a/api/server/router/image/image_routes.go
+++ b/api/server/router/image/image_routes.go
@@ -7,6 +7,7 @@ import (
 	"net/http"
 	"strconv"
 	"strings"
+	"time"
 
 	"github.com/containerd/containerd/platforms"
 	"github.com/docker/docker/api/server/httputils"
@@ -20,6 +21,7 @@ import (
 	"github.com/docker/docker/registry"
 	specs "github.com/opencontainers/image-spec/specs-go/v1"
 	"github.com/pkg/errors"
+	"github.com/sirupsen/logrus"
 )
 
 // Creates an image from Pull or from Import
@@ -40,6 +42,10 @@ func (s *imageRouter) postImagesCreate(ctx context.Context, w http.ResponseWrite
 	)
 	defer output.Close()
 
+	logrus.Debugf("PULL: The image pull request is received by the API server.")
+
+	// start := time.Now()
+
 	w.Header().Set("Content-Type", "application/json")
 
 	version := httputils.VersionFromContext(ctx)
@@ -57,6 +63,9 @@ func (s *imageRouter) postImagesCreate(ctx context.Context, w http.ResponseWrite
 		}
 	}
 
+	// timeElapsed := time.Since(start)
+	// logrus.Debugf("PULL: The image to pull is %s and the context is %s", timeElapsed, image)
+
 	if image != "" { // pull
 		metaHeaders := map[string][]string{}
 		for k, v := range r.Header {
@@ -75,7 +84,13 @@ func (s *imageRouter) postImagesCreate(ctx context.Context, w http.ResponseWrite
 				authConfig = &types.AuthConfig{}
 			}
 		}
+
+		start := time.Now()
+		// logrus.Debugf("PULL: The backend is type of %s", reflect.TypeOf(s.backend))
+
 		err = s.backend.PullImage(ctx, image, tag, platform, metaHeaders, authConfig, output)
+		timeElapsed := time.Since(start)
+		logrus.Debugf("PULL: The image to pull handler took %s", timeElapsed)
 	} else { // import
 		src := r.Form.Get("fromSrc")
 		// 'err' MUST NOT be defined within this block, we need any error
@@ -93,6 +108,7 @@ func (s *imageRouter) postImagesCreate(ctx context.Context, w http.ResponseWrite
 		}
 		_, _ = output.Write(streamformatter.FormatError(err))
 	}
+	logrus.Debugf("PULL: The image pull request is completed by the API server.")
 
 	return nil
 }
diff --git a/containerd/api/services/tasks/v1/tasks.pb.go b/containerd/api/services/tasks/v1/tasks.pb.go
index dcc7680893..447f930d67 100644
--- a/containerd/api/services/tasks/v1/tasks.pb.go
+++ b/containerd/api/services/tasks/v1/tasks.pb.go
@@ -22,6 +22,7 @@ import (
 	reflect "reflect"
 	strings "strings"
 	time "time"
+	"github.com/containerd/containerd/log"
 )
 
 // Reference imports to suppress errors if they are not otherwise used.
@@ -1777,6 +1778,7 @@ func _Tasks_ListPids_Handler(srv interface{}, ctx context.Context, dec func(inte
 }
 
 func _Tasks_Checkpoint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
+	log.G(ctx).Debugf("FAAS: The checkpoint handler is executing now!!!")
 	in := new(CheckpointTaskRequest)
 	if err := dec(in); err != nil {
 		return nil, err
diff --git a/containerd/integration/remote/remote_image.go b/containerd/integration/remote/remote_image.go
index 16088a9e48..86fe79e887 100644
--- a/containerd/integration/remote/remote_image.go
+++ b/containerd/integration/remote/remote_image.go
@@ -46,6 +46,7 @@ import (
 	runtimeapi "k8s.io/cri-api/pkg/apis/runtime/v1"
 
 	"github.com/containerd/containerd/integration/remote/util"
+	"github.com/sirupsen/logrus"
 )
 
 // ImageService is a gRPC implementation of internalapi.ImageManagerService.
@@ -123,6 +124,7 @@ func (r *ImageService) ImageStatus(image *runtimeapi.ImageSpec, opts ...grpc.Cal
 
 // PullImage pulls an image with authentication config.
 func (r *ImageService) PullImage(image *runtimeapi.ImageSpec, auth *runtimeapi.AuthConfig, podSandboxConfig *runtimeapi.PodSandboxConfig, opts ...grpc.CallOption) (string, error) {
+	logrus.Debugf("PULL: The pull image handler from ImageService class is executing.")
 	ctx, cancel := getContextWithCancel()
 	defer cancel()
 
diff --git a/containerd/pkg/cri/server/image_pull.go b/containerd/pkg/cri/server/image_pull.go
index a9da89c711..a9ab56713d 100644
--- a/containerd/pkg/cri/server/image_pull.go
+++ b/containerd/pkg/cri/server/image_pull.go
@@ -41,6 +41,7 @@ import (
 	"github.com/containerd/imgcrypt"
 	"github.com/containerd/imgcrypt/images/encryption"
 	imagespec "github.com/opencontainers/image-spec/specs-go/v1"
+	"github.com/sirupsen/logrus"
 	"golang.org/x/net/context"
 	runtime "k8s.io/cri-api/pkg/apis/runtime/v1"
 
@@ -90,6 +91,8 @@ import (
 
 // PullImage pulls an image with authentication config.
 func (c *criService) PullImage(ctx context.Context, r *runtime.PullImageRequest) (*runtime.PullImageResponse, error) {
+	logrus.Debugf("PULL: The pull image handler from criService is executing.")
+
 	imageRef := r.GetImage().GetImage()
 	namedRef, err := distribution.ParseDockerRef(imageRef)
 	if err != nil {
diff --git a/containerd/pkg/process/init.go b/containerd/pkg/process/init.go
index 26aebdcb5a..954556c3e8 100644
--- a/containerd/pkg/process/init.go
+++ b/containerd/pkg/process/init.go
@@ -424,6 +424,7 @@ func (p *Init) Checkpoint(ctx context.Context, r *CheckpointConfig) error {
 }
 
 func (p *Init) checkpoint(ctx context.Context, r *CheckpointConfig) error {
+	log.G(ctx).Debugf("FAAS: The checkpoint task in process is executing now!!!")
 	var actions []runc.CheckpointAction
 	if !r.Exit {
 		actions = append(actions, runc.LeaveRunning)
diff --git a/containerd/pull.go b/containerd/pull.go
index 92f7719b1f..bef7a0004d 100644
--- a/containerd/pull.go
+++ b/containerd/pull.go
@@ -28,6 +28,7 @@ import (
 	"github.com/containerd/containerd/remotes/docker"
 	"github.com/containerd/containerd/remotes/docker/schema1"
 	ocispec "github.com/opencontainers/image-spec/specs-go/v1"
+	"github.com/sirupsen/logrus"
 	"golang.org/x/sync/errgroup"
 	"golang.org/x/sync/semaphore"
 )
@@ -35,6 +36,7 @@ import (
 // Pull downloads the provided content into containerd's content store
 // and returns a platform specific image object
 func (c *Client) Pull(ctx context.Context, ref string, opts ...RemoteOpt) (_ Image, retErr error) {
+	logrus.Debugf("PULL: The client Pull function is executing")
 	pullCtx := defaultRemoteContext()
 	for _, o := range opts {
 		if err := o(c, pullCtx); err != nil {
diff --git a/containerd/runtime/v1/linux/task.go b/containerd/runtime/v1/linux/task.go
index 3ac7839ff0..0804b819b9 100644
--- a/containerd/runtime/v1/linux/task.go
+++ b/containerd/runtime/v1/linux/task.go
@@ -294,6 +294,7 @@ func (t *Task) CloseIO(ctx context.Context) error {
 
 // Checkpoint creates a system level dump of the task and process information that can be later restored
 func (t *Task) Checkpoint(ctx context.Context, path string, options *types.Any) error {
+	log.G(ctx).Debugf("FAAS: The checkpoint task in runtime v1 is executing now!!!")
 	r := &shim.CheckpointTaskRequest{
 		Path:    path,
 		Options: options,
diff --git a/containerd/runtime/v1/shim/service.go b/containerd/runtime/v1/shim/service.go
index a08757d0a7..4c158e0363 100644
--- a/containerd/runtime/v1/shim/service.go
+++ b/containerd/runtime/v1/shim/service.go
@@ -439,6 +439,7 @@ func (s *Service) CloseIO(ctx context.Context, r *shimapi.CloseIORequest) (*ptyp
 
 // Checkpoint the container
 func (s *Service) Checkpoint(ctx context.Context, r *shimapi.CheckpointTaskRequest) (*ptypes.Empty, error) {
+	log.G(ctx).Debugf("FAAS: The checkpoint task service is executing now!!!")
 	p, err := s.getInitProcess()
 	if err != nil {
 		return nil, err
diff --git a/containerd/runtime/v1/shim/v1/shim.pb.go b/containerd/runtime/v1/shim/v1/shim.pb.go
index dbc82599d6..a636845d78 100644
--- a/containerd/runtime/v1/shim/v1/shim.pb.go
+++ b/containerd/runtime/v1/shim/v1/shim.pb.go
@@ -18,6 +18,7 @@ import (
 	reflect "reflect"
 	strings "strings"
 	time "time"
+	"github.com/containerd/containerd/log"
 )
 
 // Reference imports to suppress errors if they are not otherwise used.
@@ -2819,6 +2820,7 @@ func (c *shimClient) Resume(ctx context.Context, req *types1.Empty) (*types1.Emp
 }
 
 func (c *shimClient) Checkpoint(ctx context.Context, req *CheckpointTaskRequest) (*types1.Empty, error) {
+	log.G(ctx).Debugf("FAAS: The checkpoint task shim is executing now!!!")
 	var resp types1.Empty
 	if err := c.client.Call(ctx, "containerd.runtime.linux.shim.v1.Shim", "Checkpoint", req, &resp); err != nil {
 		return nil, err
diff --git a/containerd/runtime/v2/runc/container.go b/containerd/runtime/v2/runc/container.go
index aac9dad7e9..c903b28078 100644
--- a/containerd/runtime/v2/runc/container.go
+++ b/containerd/runtime/v2/runc/container.go
@@ -31,6 +31,7 @@ import (
 	cgroupsv2 "github.com/containerd/cgroups/v2"
 	"github.com/containerd/console"
 	"github.com/containerd/containerd/errdefs"
+	"github.com/containerd/containerd/log"
 	"github.com/containerd/containerd/mount"
 	"github.com/containerd/containerd/namespaces"
 	"github.com/containerd/containerd/pkg/process"
@@ -461,6 +462,7 @@ func (c *Container) CloseIO(ctx context.Context, r *task.CloseIORequest) error {
 
 // Checkpoint the container
 func (c *Container) Checkpoint(ctx context.Context, r *task.CheckpointTaskRequest) error {
+	log.G(ctx).Debugf("FAAS: The checkpoint container is executing now!!!")
 	p, err := c.Process("")
 	if err != nil {
 		return err
diff --git a/containerd/runtime/v2/runc/task/service.go b/containerd/runtime/v2/runc/task/service.go
index d6af20fb03..3d39d8fe00 100644
--- a/containerd/runtime/v2/runc/task/service.go
+++ b/containerd/runtime/v2/runc/task/service.go
@@ -30,6 +30,7 @@ import (
 	eventstypes "github.com/containerd/containerd/api/events"
 	"github.com/containerd/containerd/api/types/task"
 	"github.com/containerd/containerd/errdefs"
+	"github.com/containerd/containerd/log"
 	"github.com/containerd/containerd/namespaces"
 	"github.com/containerd/containerd/pkg/oom"
 	oomv1 "github.com/containerd/containerd/pkg/oom/v1"
@@ -504,6 +505,7 @@ func (s *service) CloseIO(ctx context.Context, r *taskAPI.CloseIORequest) (*ptyp
 
 // Checkpoint the container
 func (s *service) Checkpoint(ctx context.Context, r *taskAPI.CheckpointTaskRequest) (*ptypes.Empty, error) {
+	log.G(ctx).Debugf("FAAS: The checkpoint service v2 is executing now!!!")
 	container, err := s.getContainer(r.ID)
 	if err != nil {
 		return nil, err
diff --git a/containerd/runtime/v2/runc/v1/service.go b/containerd/runtime/v2/runc/v1/service.go
index 8c473430e2..ef0be674a6 100644
--- a/containerd/runtime/v2/runc/v1/service.go
+++ b/containerd/runtime/v2/runc/v1/service.go
@@ -34,6 +34,7 @@ import (
 	eventstypes "github.com/containerd/containerd/api/events"
 	"github.com/containerd/containerd/api/types/task"
 	"github.com/containerd/containerd/errdefs"
+	"github.com/containerd/containerd/log"
 	"github.com/containerd/containerd/mount"
 	"github.com/containerd/containerd/namespaces"
 	"github.com/containerd/containerd/pkg/oom"
@@ -536,6 +537,7 @@ func (s *service) CloseIO(ctx context.Context, r *taskAPI.CloseIORequest) (*ptyp
 
 // Checkpoint the container
 func (s *service) Checkpoint(ctx context.Context, r *taskAPI.CheckpointTaskRequest) (*ptypes.Empty, error) {
+	log.G(ctx).Debugf("FAAS: The checkpoint runtime v2 service is executing now!!!")
 	container, err := s.getContainer()
 	if err != nil {
 		return nil, err
diff --git a/containerd/services/content/contentserver/contentserver.go b/containerd/services/content/contentserver/contentserver.go
index eb5855a476..8dc98bc07d 100644
--- a/containerd/services/content/contentserver/contentserver.go
+++ b/containerd/services/content/contentserver/contentserver.go
@@ -21,6 +21,7 @@ import (
 	"fmt"
 	"io"
 	"sync"
+	"time"
 
 	api "github.com/containerd/containerd/api/services/content/v1"
 	"github.com/containerd/containerd/content"
@@ -258,6 +259,8 @@ func (s *service) Write(session api.Content_WriteServer) (err error) {
 		expected digest.Digest
 	)
 
+	log.G(ctx).Debugf("FAASCONT: The write into the content server is getting invoked.")
+
 	defer func(msg *api.WriteContentResponse) {
 		// pump through the last message if no error was encountered
 		if err != nil {
@@ -283,6 +286,8 @@ func (s *service) Write(session api.Content_WriteServer) (err error) {
 		return err
 	}
 
+	start := time.Now()
+
 	ref = req.Ref
 
 	if ref == "" {
@@ -292,6 +297,7 @@ func (s *service) Write(session api.Content_WriteServer) (err error) {
 	fields := logrus.Fields{
 		"ref": ref,
 	}
+
 	total = req.Total
 	expected = req.Expected
 	if total > 0 {
@@ -302,9 +308,15 @@ func (s *service) Write(session api.Content_WriteServer) (err error) {
 		fields["expected"] = expected
 	}
 
+	timeElapsed := time.Since(start)
+	log.G(ctx).Debugf("FAASCONT: The content server writer fields read took %s seconds", timeElapsed)
+
 	ctx = log.WithLogger(ctx, log.G(ctx).WithFields(fields))
 
 	log.G(ctx).Debug("(*service).Write started")
+
+	start = time.Now()
+
 	// this action locks the writer for the session.
 	wr, err := s.store.Writer(ctx,
 		content.WithRef(ref),
@@ -312,8 +324,15 @@ func (s *service) Write(session api.Content_WriteServer) (err error) {
 	if err != nil {
 		return errdefs.ToGRPC(err)
 	}
+
+	timeElapsed = time.Since(start)
+	log.G(ctx).Debugf("FAASCONT: The content server writer lock acquired in %s seconds", timeElapsed)
+
 	defer wr.Close()
 
+	log.G(ctx).Debugf("FAASCONT: The content server writer got request for %v ", req)
+
+	// start = time.Now()
 	for {
 		msg.Action = req.Action
 		ws, err := wr.Status()
@@ -436,6 +455,7 @@ func (s *service) Write(session api.Content_WriteServer) (err error) {
 			return err
 		}
 	}
+
 }
 
 func (s *service) Abort(ctx context.Context, req *api.AbortRequest) (*ptypes.Empty, error) {
diff --git a/containerd/services/tasks/local.go b/containerd/services/tasks/local.go
index 96ed36ca4a..c42339e742 100644
--- a/containerd/services/tasks/local.go
+++ b/containerd/services/tasks/local.go
@@ -536,18 +536,27 @@ func (l *local) CloseIO(ctx context.Context, r *api.CloseIORequest, _ ...grpc.Ca
 }
 
 func (l *local) Checkpoint(ctx context.Context, r *api.CheckpointTaskRequest, _ ...grpc.CallOption) (*api.CheckpointTaskResponse, error) {
+	log.G(ctx).Debugf("FAASCONT: The checkpoint local task is executing now!!!")
+
+	log.G(ctx).Debugf("FAASCONT: The checkpoint task request is %v", r)
+
+	start := time.Now()
+
 	container, err := l.getContainer(ctx, r.ContainerID)
 	if err != nil {
 		return nil, err
 	}
+
 	t, err := l.getTaskFromContainer(ctx, container)
 	if err != nil {
 		return nil, err
 	}
+
 	image, err := getCheckpointPath(container.Runtime.Name, r.Options)
 	if err != nil {
 		return nil, err
 	}
+
 	checkpointImageExists := false
 	if image == "" {
 		checkpointImageExists = true
@@ -557,16 +566,30 @@ func (l *local) Checkpoint(ctx context.Context, r *api.CheckpointTaskRequest, _
 		}
 		defer os.RemoveAll(image)
 	}
+
+	timeElapsed := time.Since(start)
+	log.G(ctx).Debugf("FAASCONT: The container checkpoint input and configure options are fetched in %s seconds", timeElapsed)
+
+	start = time.Now()
+
 	if err := t.Checkpoint(ctx, image, r.Options); err != nil {
 		return nil, errdefs.ToGRPC(err)
 	}
+
+	timeElapsed = time.Since(start)
+	log.G(ctx).Debugf("FAASCONT: The container checkpoint took %s seconds", timeElapsed)
+
 	// do not commit checkpoint image if checkpoint ImagePath is passed,
 	// return if checkpointImageExists is false
 	if !checkpointImageExists {
 		return &api.CheckpointTaskResponse{}, nil
 	}
+
+	start = time.Now()
+
 	// write checkpoint to the content store
 	tar := archive.Diff(ctx, "", image)
+	log.G(ctx).Debugf("FAASCONT: The container checkpoint diff is stored in %v", tar)
 	cp, err := l.writeContent(ctx, images.MediaTypeContainerd1Checkpoint, image, tar)
 	// close tar first after write
 	if err := tar.Close(); err != nil {
@@ -575,8 +598,15 @@ func (l *local) Checkpoint(ctx context.Context, r *api.CheckpointTaskRequest, _
 	if err != nil {
 		return nil, err
 	}
+
+	timeElapsed = time.Since(start)
+	log.G(ctx).Debugf("FAASCONT: The container checkpoint create diff and write content in %s seconds", timeElapsed)
+
+	start = time.Now()
+
 	// write the config to the content store
 	data, err := container.Spec.Marshal()
+	log.G(ctx).Debugf("FAASCONT: The container checkpoint spec is %s and the image is %v", data, image)
 	if err != nil {
 		return nil, err
 	}
@@ -585,6 +615,10 @@ func (l *local) Checkpoint(ctx context.Context, r *api.CheckpointTaskRequest, _
 	if err != nil {
 		return nil, errdefs.ToGRPC(err)
 	}
+
+	timeElapsed = time.Since(start)
+	log.G(ctx).Debugf("FAASCONT: The container checkpoint write container spec in %s seconds", timeElapsed)
+
 	return &api.CheckpointTaskResponse{
 		Descriptors: []*types.Descriptor{
 			cp,
@@ -679,6 +713,9 @@ func (l *local) writeContent(ctx context.Context, mediaType, ref string, r io.Re
 		return nil, err
 	}
 	defer writer.Close()
+
+	// log.G(ctx).Debugf("The writer object is %s and io.Reader is %s", writer, r)
+
 	size, err := io.Copy(writer, r)
 	if err != nil {
 		return nil, err
diff --git a/containerd/task.go b/containerd/task.go
index ef8cd44942..c4606b0a58 100644
--- a/containerd/task.go
+++ b/containerd/task.go
@@ -35,6 +35,7 @@ import (
 	"github.com/containerd/containerd/diff"
 	"github.com/containerd/containerd/errdefs"
 	"github.com/containerd/containerd/images"
+	"github.com/containerd/containerd/log"
 	"github.com/containerd/containerd/mount"
 	"github.com/containerd/containerd/oci"
 	"github.com/containerd/containerd/plugin"
@@ -438,6 +439,7 @@ func (t *task) Resize(ctx context.Context, w, h uint32) error {
 // NOTE: Checkpoint supports to dump task information to a directory, in this way, an empty
 // OCI Index will be returned.
 func (t *task) Checkpoint(ctx context.Context, opts ...CheckpointTaskOpts) (Image, error) {
+	log.G(ctx).Debugf("FAAS: The checkpoint task is executing now!!!")
 	ctx, done, err := t.client.WithLease(ctx)
 	if err != nil {
 		return nil, err
diff --git a/daemon/checkpoint.go b/daemon/checkpoint.go
index 5cbe8574ab..0e3c713d69 100644
--- a/daemon/checkpoint.go
+++ b/daemon/checkpoint.go
@@ -5,9 +5,11 @@ import (
 	"fmt"
 	"os"
 	"path/filepath"
+	"time"
 
 	"github.com/docker/docker/api/types"
 	"github.com/docker/docker/daemon/names"
+	"github.com/sirupsen/logrus"
 )
 
 var (
@@ -52,6 +54,9 @@ func getCheckpointDir(checkDir, checkpointID, ctrName, ctrID, ctrCheckpointDir s
 
 // CheckpointCreate checkpoints the process running in a container with CRIU
 func (daemon *Daemon) CheckpointCreate(name string, config types.CheckpointCreateOptions) error {
+	logrus.Debugf("FAAS: The checkpoint request is received")
+	start := time.Now()
+
 	container, err := daemon.GetContainer(name)
 	if err != nil {
 		return err
@@ -61,6 +66,9 @@ func (daemon *Daemon) CheckpointCreate(name string, config types.CheckpointCreat
 		return fmt.Errorf("Container %s not running", name)
 	}
 
+	timeElapsed := time.Since(start)
+	logrus.Debugf("FAAS: The container details are fetched in %s seconds", timeElapsed)
+
 	if !validCheckpointNamePattern.MatchString(config.CheckpointID) {
 		return fmt.Errorf("Invalid checkpoint ID (%s), only %s are allowed", config.CheckpointID, validCheckpointNameChars)
 	}
@@ -70,12 +78,16 @@ func (daemon *Daemon) CheckpointCreate(name string, config types.CheckpointCreat
 		return fmt.Errorf("cannot checkpoint container %s: %s", name, err)
 	}
 
+	start = time.Now()
 	err = daemon.containerd.CreateCheckpoint(context.Background(), container.ID, checkpointDir, config.Exit)
 	if err != nil {
 		os.RemoveAll(checkpointDir)
 		return fmt.Errorf("Cannot checkpoint container %s: %s", name, err)
 	}
 
+	timeElapsed = time.Since(start)
+	logrus.Debugf("FAAS: The checkpoint created fetched in %s seconds", timeElapsed)
+
 	daemon.LogContainerEvent(container, "checkpoint")
 
 	return nil
diff --git a/daemon/graphdriver/overlay2/overlay.go b/daemon/graphdriver/overlay2/overlay.go
index 444f600f55..0c8e789278 100644
--- a/daemon/graphdriver/overlay2/overlay.go
+++ b/daemon/graphdriver/overlay2/overlay.go
@@ -693,6 +693,7 @@ func (d *Driver) isParent(id, parent string) bool {
 
 // ApplyDiff applies the new layer into a root
 func (d *Driver) ApplyDiff(id string, parent string, diff io.Reader) (size int64, err error) {
+	logrus.Debugf("STORAGE: The applydiff of overlay")
 	if useNaiveDiff(d.home) || !d.isParent(id, parent) {
 		return d.naiveDiff.ApplyDiff(id, parent, diff)
 	}
diff --git a/distribution/pull_v2.go b/distribution/pull_v2.go
index 9ce108f547..6cb991e507 100644
--- a/distribution/pull_v2.go
+++ b/distribution/pull_v2.go
@@ -97,6 +97,7 @@ func (p *v2Puller) Pull(ctx context.Context, ref reference.Named, platform *spec
 
 func (p *v2Puller) pullV2Repository(ctx context.Context, ref reference.Named, platform *specs.Platform) (err error) {
 	var layersDownloaded bool
+	start := time.Now()
 	if !reference.IsNameOnly(ref) {
 		layersDownloaded, err = p.pullV2Tag(ctx, ref, platform)
 		if err != nil {
@@ -135,6 +136,8 @@ func (p *v2Puller) pullV2Repository(ctx context.Context, ref reference.Named, pl
 			layersDownloaded = layersDownloaded || pulledNew
 		}
 	}
+	timeElapsed := time.Since(start)
+	logrus.Debugf("PULL: The pull v2 Newv2repository took %s", timeElapsed)
 
 	writeStatus(reference.FamiliarString(ref), p.config.ProgressOutput, layersDownloaded)
 
@@ -169,6 +172,7 @@ func (ld *v2LayerDescriptor) DiffID() (layer.DiffID, error) {
 
 func (ld *v2LayerDescriptor) Download(ctx context.Context, progressOutput progress.Output) (io.ReadCloser, int64, error) {
 	logrus.Debugf("pulling blob %q", ld.digest)
+	start := time.Now()
 
 	var (
 		err    error
@@ -295,6 +299,9 @@ func (ld *v2LayerDescriptor) Download(ctx context.Context, progressOutput progre
 	// be closed once
 	ld.tmpFile = nil
 
+	timeElapsed := time.Since(start)
+	logrus.Debugf("PULL_STATS: The download of the layer:%s took: %s", ld.digest, timeElapsed)
+
 	return ioutils.NewReadCloserWrapper(tmpFile, func() error {
 		tmpFile.Close()
 		err := os.RemoveAll(tmpFile.Name())
@@ -346,6 +353,8 @@ func (p *v2Puller) pullV2Tag(ctx context.Context, ref reference.Named, platform
 		tagged      reference.NamedTagged
 		isTagged    bool
 	)
+
+	start := time.Now()
 	if digested, isDigested := ref.(reference.Canonical); isDigested {
 		dgst = digested.Digest()
 		tagOrDigest = digested.String()
@@ -364,6 +373,9 @@ func (p *v2Puller) pullV2Tag(ctx context.Context, ref reference.Named, platform
 		return false, fmt.Errorf("internal error: reference has neither a tag nor a digest: %s", reference.FamiliarString(ref))
 	}
 
+	timeElapsed := time.Since(start)
+	logrus.Debugf("PULL: The tag of an image took %s", timeElapsed)
+
 	ctx = log.WithLogger(ctx, logrus.WithFields(
 		logrus.Fields{
 			"digest": dgst,
@@ -376,6 +388,7 @@ func (p *v2Puller) pullV2Tag(ctx context.Context, ref reference.Named, platform
 		Size:      size,
 	}
 
+	start = time.Now()
 	manifest, err := p.manifestStore.Get(ctx, desc, ref)
 	if err != nil {
 		if isTagged && isNotFound(errors.Cause(err)) {
@@ -411,6 +424,9 @@ func (p *v2Puller) pullV2Tag(ctx context.Context, ref reference.Named, platform
 		return false, fmt.Errorf("image manifest does not exist for tag or digest %q", tagOrDigest)
 	}
 
+	timeElapsed = time.Since(start)
+	logrus.Debugf("PULL: The pullv2Tag manifest of an image took %s", timeElapsed)
+
 	if m, ok := manifest.(*schema2.DeserializedManifest); ok {
 		var allowedMediatype bool
 		for _, t := range p.config.Schema2Types {
@@ -632,6 +648,7 @@ func checkSupportedMediaType(mediaType string) error {
 }
 
 func (p *v2Puller) pullSchema2Layers(ctx context.Context, target distribution.Descriptor, layers []distribution.Descriptor, platform *specs.Platform) (id digest.Digest, err error) {
+	logrus.Debugf("PULL: The pullSchema2Layers is going to get executed.")
 	if _, err := p.config.ImageStore.Get(ctx, target.Digest); err == nil {
 		// If the image already exists locally, no need to pull
 		// anything.
@@ -741,6 +758,8 @@ func (p *v2Puller) pullSchema2Layers(ctx context.Context, target distribution.De
 				err    error
 				rootFS image.RootFS
 			)
+
+			start := time.Now()
 			downloadRootFS := *image.NewRootFS()
 			rootFS, release, err = p.config.DownloadManager.Download(ctx, downloadRootFS, layerStoreOS, descriptors, p.config.ProgressOutput)
 			if err != nil {
@@ -750,6 +769,9 @@ func (p *v2Puller) pullSchema2Layers(ctx context.Context, target distribution.De
 				layerErrChan <- err
 				return
 			}
+			endTime := time.Now()
+			timeElapsed := endTime.Sub(start)
+			logrus.Debugf("PULL: The pullSchema2Layers download manager took %s", timeElapsed)
 
 			downloadedRootFS = &rootFS
 			close(downloadsDone)
@@ -774,16 +796,24 @@ func (p *v2Puller) pullSchema2Layers(ctx context.Context, target distribution.De
 		}
 	}
 
+	// The following line wait until the downloads and the configuration is completed
 	select {
 	case <-downloadsDone:
 	case err = <-layerErrChan:
 		return "", err
 	}
 
+	start := time.Now()
+
 	if release != nil {
 		defer release()
 	}
 
+	timeElapsed := time.Since(start)
+	logrus.Debugf("PULL: The pullSchema2Layers release took %s", timeElapsed)
+
+	start = time.Now()
+
 	if downloadedRootFS != nil {
 		// The DiffIDs returned in rootFS MUST match those in the config.
 		// Otherwise the image config could be referencing layers that aren't
@@ -799,6 +829,9 @@ func (p *v2Puller) pullSchema2Layers(ctx context.Context, target distribution.De
 		}
 	}
 
+	timeElapsed = time.Since(start)
+	logrus.Debugf("PULL: The pullSchema2Layers downloadedRootFS took %s", timeElapsed)
+
 	imageID, err := p.config.ImageStore.Put(ctx, configJSON)
 	if err != nil {
 		return "", err
@@ -875,6 +908,7 @@ func (p *v2Puller) pullManifestList(ctx context.Context, ref reference.Named, mf
 		return "", "", err
 	}
 
+	start := time.Now()
 	desc := specs.Descriptor{
 		Digest:    match.Digest,
 		Size:      match.Size,
@@ -884,6 +918,8 @@ func (p *v2Puller) pullManifestList(ctx context.Context, ref reference.Named, mf
 	if err != nil {
 		return "", "", err
 	}
+	timeElapsed := time.Since(start)
+	logrus.Debugf("PULL: The pullmanifest manifeststore get operation took %s", timeElapsed)
 
 	manifestRef, err := reference.WithDigest(reference.TrimNamed(ref), match.Digest)
 	if err != nil {
diff --git a/distribution/xfer/download.go b/distribution/xfer/download.go
index 45eb3660b7..a95009bf3a 100644
--- a/distribution/xfer/download.go
+++ b/distribution/xfer/download.go
@@ -115,6 +115,7 @@ func (ldm *LayerDownloadManager) Download(ctx context.Context, initialRootFS ima
 		transferKey    = ""
 		downloadsByKey = make(map[string]*downloadTransfer)
 	)
+	logrus.Debugf("STORAGE: The function is downloading the layer")
 
 	// Assume that the operating system is the host OS if blank, and validate it
 	// to ensure we don't cause a panic by an invalid index into the layerstores.
@@ -201,6 +202,8 @@ func (ldm *LayerDownloadManager) Download(ctx context.Context, initialRootFS ima
 		}
 	}()
 
+	logrus.Debugf("STORAGE: The function is done downloading")
+
 	select {
 	case <-ctx.Done():
 		topDownload.Transfer.Release(watcher)
@@ -209,12 +212,16 @@ func (ldm *LayerDownloadManager) Download(ctx context.Context, initialRootFS ima
 		break
 	}
 
+	logrus.Debugf("STORAGE: The function is done downloading")
+
 	l, err := topDownload.result()
 	if err != nil {
 		topDownload.Transfer.Release(watcher)
 		return rootFS, func() {}, err
 	}
 
+	logrus.Debugf("STORAGE: The function is done downloading")
+
 	// Must do this exactly len(layers) times, so we don't include the
 	// base layer on Windows.
 	for range layers {
@@ -225,6 +232,8 @@ func (ldm *LayerDownloadManager) Download(ctx context.Context, initialRootFS ima
 		rootFS.DiffIDs = append([]layer.DiffID{l.DiffID()}, rootFS.DiffIDs...)
 		l = l.Parent()
 	}
+
+	logrus.Debugf("STORAGE: The function is done downloading")
 	return rootFS, func() { topDownload.Transfer.Release(watcher) }, err
 }
 
diff --git a/layer/layer_store.go b/layer/layer_store.go
index 5520899b8d..aba238a93d 100644
--- a/layer/layer_store.go
+++ b/layer/layer_store.go
@@ -7,6 +7,7 @@ import (
 	"os"
 	"path/filepath"
 	"sync"
+	"time"
 
 	"github.com/docker/distribution"
 	"github.com/docker/docker/daemon/graphdriver"
@@ -241,6 +242,7 @@ func (ls *layerStore) loadMount(mount string) error {
 }
 
 func (ls *layerStore) applyTar(tx *fileMetadataTransaction, ts io.Reader, parent string, layer *roLayer) error {
+	logrus.Debugf("STORAGE: The applyTar of layerStorage")
 	digester := digest.Canonical.Digester()
 	tr := io.TeeReader(ts, digester.Hash())
 
@@ -283,6 +285,9 @@ func (ls *layerStore) Register(ts io.Reader, parent ChainID) (Layer, error) {
 }
 
 func (ls *layerStore) registerWithDescriptor(ts io.Reader, parent ChainID, descriptor distribution.Descriptor) (Layer, error) {
+	logrus.Debugf("STORAGE: The registerWithDescriptor is executing")
+	start := time.Now()
+
 	// err is used to hold the error which will always trigger
 	// cleanup of creates sources but may not be an error returned
 	// to the caller (already exists).
@@ -369,6 +374,10 @@ func (ls *layerStore) registerWithDescriptor(ts io.Reader, parent ChainID, descr
 	}
 
 	ls.layerMap[layer.chainID] = layer
+	timeElapsed := time.Since(start)
+	logrus.Debugf("PULL_STATS: The apply tar operation of layer took: %s", timeElapsed)
+
+	logrus.Debugf("PULL: registerwithDescriptor function is completed execution!!!")
 
 	return layer.getReference(), nil
 }
diff --git a/libcontainerd/remote/client.go b/libcontainerd/remote/client.go
index c6f4745981..26eff71b93 100644
--- a/libcontainerd/remote/client.go
+++ b/libcontainerd/remote/client.go
@@ -538,34 +538,57 @@ func (c *client) getCheckpointOptions(id string, exit bool) containerd.Checkpoin
 }
 
 func (c *client) CreateCheckpoint(ctx context.Context, containerID, checkpointDir string, exit bool) error {
+	logrus.Debugf("FAAS: The containerd runtime has received the request for checkpointing.")
+
+	start := time.Now()
 	p, err := c.getProcess(ctx, containerID, libcontainerdtypes.InitProcessName)
 	if err != nil {
 		return err
 	}
 
+	timeElapsed := time.Since(start)
+	logrus.Debugf("FAAS: The container get process costs %s seconds", timeElapsed)
+
+	start = time.Now()
 	opts := []containerd.CheckpointTaskOpts{c.getCheckpointOptions(containerID, exit)}
+
 	img, err := p.(containerd.Task).Checkpoint(ctx, opts...)
 	if err != nil {
 		return wrapError(err)
 	}
+
+	timeElapsed = time.Since(start)
+	logrus.Debugf("FAAS: The container checkpoint process costs %s seconds", timeElapsed)
+
 	// Whatever happens, delete the checkpoint from containerd
 	defer func() {
+		start = time.Now()
 		err := c.client.ImageService().Delete(context.Background(), img.Name())
 		if err != nil {
 			c.logger.WithError(err).WithField("digest", img.Target().Digest).
 				Warnf("failed to delete checkpoint image")
 		}
+		timeElapsed = time.Since(start)
+		logrus.Debugf("FAAS: The deferred deletion of the image takes %s seconds", timeElapsed)
 	}()
 
+	start = time.Now()
 	b, err := content.ReadBlob(ctx, c.client.ContentStore(), img.Target())
 	if err != nil {
 		return errdefs.System(errors.Wrapf(err, "failed to retrieve checkpoint data"))
 	}
+	timeElapsed = time.Since(start)
+	logrus.Debugf("FAAS: The retrieve checkpoint data takes %s seconds", timeElapsed)
+
+	start = time.Now()
 	var index v1.Index
 	if err := json.Unmarshal(b, &index); err != nil {
 		return errdefs.System(errors.Wrapf(err, "failed to decode checkpoint data"))
 	}
+	timeElapsed = time.Since(start)
+	logrus.Debugf("FAAS: The decode checkpoint data takes %s seconds", timeElapsed)
 
+	start = time.Now()
 	var cpDesc *v1.Descriptor
 	for _, m := range index.Manifests {
 		m := m
@@ -577,7 +600,10 @@ func (c *client) CreateCheckpoint(ctx context.Context, containerID, checkpointDi
 	if cpDesc == nil {
 		return errdefs.System(errors.Wrapf(err, "invalid checkpoint"))
 	}
+	timeElapsed = time.Since(start)
+	logrus.Debugf("FAAS: The checkpoint validation takes %s seconds", timeElapsed)
 
+	start = time.Now()
 	rat, err := c.client.ContentStore().ReaderAt(ctx, *cpDesc)
 	if err != nil {
 		return errdefs.System(errors.Wrapf(err, "failed to get checkpoint reader"))
@@ -587,6 +613,8 @@ func (c *client) CreateCheckpoint(ctx context.Context, containerID, checkpointDi
 	if err != nil {
 		return errdefs.System(errors.Wrapf(err, "failed to read checkpoint reader"))
 	}
+	timeElapsed = time.Since(start)
+	logrus.Debugf("FAAS: The checkpoint reader takes %s seconds", timeElapsed)
 
 	return err
 }
diff --git a/pkg/archive/archive.go b/pkg/archive/archive.go
index ade5f5396b..2e68fac5bd 100644
--- a/pkg/archive/archive.go
+++ b/pkg/archive/archive.go
@@ -182,6 +182,12 @@ func wrapReadCloser(readBuf io.ReadCloser, cancel context.CancelFunc) io.ReadClo
 
 // DecompressStream decompresses the archive and returns a ReaderCloser with the decompressed archive.
 func DecompressStream(archive io.Reader) (io.ReadCloser, error) {
+	pc, _, _, _ := runtime.Caller(1)
+	callerFunctionName := runtime.FuncForPC(pc).Name()
+
+	logrus.Debugf("Caller function: %s\n", callerFunctionName)
+	start := time.Now()
+
 	p := pools.BufioReader32KPool
 	buf := p.Get(archive)
 	bs, err := buf.Peek(10)
@@ -209,6 +215,8 @@ func DecompressStream(archive io.Reader) (io.ReadCloser, error) {
 			return nil, err
 		}
 		readBufWrapper := p.NewReadCloserWrapper(buf, gzReader)
+		timeElapsed := time.Since(start)
+		logrus.Debugf("PULL_STATS: The decompress operation took: %s", timeElapsed)
 		return wrapReadCloser(readBufWrapper, cancel), nil
 	case Bzip2:
 		bz2Reader := bzip2.NewReader(buf)
@@ -227,6 +235,7 @@ func DecompressStream(archive io.Reader) (io.ReadCloser, error) {
 	default:
 		return nil, fmt.Errorf("Unsupported compression format %s", (&compression).Extension())
 	}
+
 }
 
 // CompressStream compresses the dest with specified compression algorithm.
diff --git a/plugin/backend_linux.go b/plugin/backend_linux.go
index 834f5a8119..ab8c98c4e4 100644
--- a/plugin/backend_linux.go
+++ b/plugin/backend_linux.go
@@ -255,6 +255,7 @@ func (pm *Manager) Upgrade(ctx context.Context, ref reference.Named, name string
 //
 // TODO: replace reference package usage with simpler url.Parse semantics
 func (pm *Manager) Pull(ctx context.Context, ref reference.Named, name string, metaHeader http.Header, authConfig *types.AuthConfig, privileges types.PluginPrivileges, outStream io.Writer, opts ...CreateOpt) (err error) {
+	logrus.Debugf("PULL: The manager Pull function is executing")
 	pm.muGC.RLock()
 	defer pm.muGC.RUnlock()
 
diff --git a/vendor/github.com/containerd/containerd/api/services/tasks/v1/tasks.pb.go b/vendor/github.com/containerd/containerd/api/services/tasks/v1/tasks.pb.go
index 5ac5af11b9..520c207c31 100644
--- a/vendor/github.com/containerd/containerd/api/services/tasks/v1/tasks.pb.go
+++ b/vendor/github.com/containerd/containerd/api/services/tasks/v1/tasks.pb.go
@@ -21,6 +21,7 @@ import (
 	reflect "reflect"
 	strings "strings"
 	time "time"
+	"github.com/sirupsen/logrus"
 )
 
 // Reference imports to suppress errors if they are not otherwise used.
@@ -1413,11 +1414,18 @@ func (c *tasksClient) ListPids(ctx context.Context, in *ListPidsRequest, opts ..
 }
 
 func (c *tasksClient) Checkpoint(ctx context.Context, in *CheckpointTaskRequest, opts ...grpc.CallOption) (*CheckpointTaskResponse, error) {
+	logrus.Debugf("FAAS: The taskclient executes the checkpoint function!!")
+	logrus.Debugf("FAAS: The taskclient gets the in request %v", in)
+	logrus.Debugf("FAAS: The taskclient gets the opts request %v", opts)
+	logrus.Debugf("FAAS: The taskclient gets the context request %v", ctx)
+	logrus.Debugf("FAAS: The taskclient gets the connection type %s", reflect.TypeOf(c.cc))
+
 	out := new(CheckpointTaskResponse)
 	err := c.cc.Invoke(ctx, "/containerd.services.tasks.v1.Tasks/Checkpoint", in, out, opts...)
 	if err != nil {
 		return nil, err
 	}
+	logrus.Debugf("FAAS: The taskclient receives the response %v", out)
 	return out, nil
 }
 
diff --git a/vendor/github.com/containerd/containerd/container.go b/vendor/github.com/containerd/containerd/container.go
index 8384a481fc..3d7e242863 100644
--- a/vendor/github.com/containerd/containerd/container.go
+++ b/vendor/github.com/containerd/containerd/container.go
@@ -39,6 +39,7 @@ import (
 	ocispec "github.com/opencontainers/image-spec/specs-go/v1"
 	"github.com/opencontainers/selinux/go-selinux/label"
 	"github.com/pkg/errors"
+	"github.com/sirupsen/logrus"
 )
 
 const (
@@ -321,6 +322,8 @@ func (c *container) Update(ctx context.Context, opts ...UpdateContainerOpts) err
 }
 
 func (c *container) Checkpoint(ctx context.Context, ref string, opts ...CheckpointOpts) (Image, error) {
+	logrus.Debugf("FAAS: The checkpoint code in the containerd container.go file is executed!!")
+
 	index := &ocispec.Index{
 		Versioned: ver.Versioned{
 			SchemaVersion: 2,
@@ -376,12 +379,14 @@ func (c *container) Checkpoint(ctx context.Context, ref string, opts ...Checkpoi
 		Name:   ref,
 		Target: desc,
 	}
+
 	checkpoint, err := c.client.ImageService().Create(ctx, i)
 	if err != nil {
 		return nil, err
 	}
 
 	return NewImage(c.client, checkpoint), nil
+
 }
 
 func (c *container) loadTask(ctx context.Context, ioAttach cio.Attach) (Task, error) {
diff --git a/vendor/github.com/containerd/containerd/pkg/process/init.go b/vendor/github.com/containerd/containerd/pkg/process/init.go
index 28ca5ac6a0..70ce65280a 100644
--- a/vendor/github.com/containerd/containerd/pkg/process/init.go
+++ b/vendor/github.com/containerd/containerd/pkg/process/init.go
@@ -1,3 +1,4 @@
+//go:build !windows
 // +build !windows
 
 /*
diff --git a/vendor/github.com/containerd/containerd/pull.go b/vendor/github.com/containerd/containerd/pull.go
index 36365513f6..448c713352 100644
--- a/vendor/github.com/containerd/containerd/pull.go
+++ b/vendor/github.com/containerd/containerd/pull.go
@@ -27,6 +27,7 @@ import (
 	"github.com/containerd/containerd/remotes/docker/schema1"
 	ocispec "github.com/opencontainers/image-spec/specs-go/v1"
 	"github.com/pkg/errors"
+	"github.com/sirupsen/logrus"
 	"golang.org/x/sync/errgroup"
 	"golang.org/x/sync/semaphore"
 )
@@ -34,6 +35,7 @@ import (
 // Pull downloads the provided content into containerd's content store
 // and returns a platform specific image object
 func (c *Client) Pull(ctx context.Context, ref string, opts ...RemoteOpt) (_ Image, retErr error) {
+	logrus.Debugf("PULL: The containerd Pull function is executing")
 	pullCtx := defaultRemoteContext()
 	for _, o := range opts {
 		if err := o(c, pullCtx); err != nil {
diff --git a/vendor/github.com/containerd/containerd/runtime/v1/linux/task.go b/vendor/github.com/containerd/containerd/runtime/v1/linux/task.go
index 89390b06ab..e20a06294b 100644
--- a/vendor/github.com/containerd/containerd/runtime/v1/linux/task.go
+++ b/vendor/github.com/containerd/containerd/runtime/v1/linux/task.go
@@ -1,3 +1,4 @@
+//go:build linux
 // +build linux
 
 /*
@@ -36,6 +37,7 @@ import (
 	"github.com/containerd/typeurl"
 	"github.com/gogo/protobuf/types"
 	"github.com/pkg/errors"
+	"github.com/sirupsen/logrus"
 )
 
 // Task on a linux based system
@@ -292,6 +294,7 @@ func (t *Task) CloseIO(ctx context.Context) error {
 
 // Checkpoint creates a system level dump of the task and process information that can be later restored
 func (t *Task) Checkpoint(ctx context.Context, path string, options *types.Any) error {
+	logrus.Debugf("FAAS: The checkpoint code in the containerd runtime task.go file is executed!!")
 	r := &shim.CheckpointTaskRequest{
 		Path:    path,
 		Options: options,
diff --git a/vendor/github.com/containerd/containerd/runtime/v1/shim/client/client.go b/vendor/github.com/containerd/containerd/runtime/v1/shim/client/client.go
index 9653454afc..2c924f891e 100644
--- a/vendor/github.com/containerd/containerd/runtime/v1/shim/client/client.go
+++ b/vendor/github.com/containerd/containerd/runtime/v1/shim/client/client.go
@@ -1,3 +1,4 @@
+//go:build !windows
 // +build !windows
 
 /*
diff --git a/vendor/github.com/containerd/containerd/runtime/v1/shim/service.go b/vendor/github.com/containerd/containerd/runtime/v1/shim/service.go
index 2f5a8c2f21..e6e96b6c69 100644
--- a/vendor/github.com/containerd/containerd/runtime/v1/shim/service.go
+++ b/vendor/github.com/containerd/containerd/runtime/v1/shim/service.go
@@ -1,3 +1,4 @@
+//go:build !windows
 // +build !windows
 
 /*
diff --git a/vendor/github.com/containerd/containerd/task.go b/vendor/github.com/containerd/containerd/task.go
index ae966ffc4b..a06027247d 100644
--- a/vendor/github.com/containerd/containerd/task.go
+++ b/vendor/github.com/containerd/containerd/task.go
@@ -22,6 +22,7 @@ import (
 	"encoding/json"
 	"fmt"
 	"io"
+	"reflect"
 	goruntime "runtime"
 	"strings"
 	"syscall"
@@ -47,6 +48,7 @@ import (
 	v1 "github.com/opencontainers/image-spec/specs-go/v1"
 	specs "github.com/opencontainers/runtime-spec/specs-go"
 	"github.com/pkg/errors"
+	"github.com/sirupsen/logrus"
 )
 
 // UnknownExitStatus is returned when containerd is unable to
@@ -418,19 +420,35 @@ func (t *task) Resize(ctx context.Context, w, h uint32) error {
 // NOTE: Checkpoint supports to dump task information to a directory, in this way, an empty
 // OCI Index will be returned.
 func (t *task) Checkpoint(ctx context.Context, opts ...CheckpointTaskOpts) (Image, error) {
+	logrus.Debugf("FAAS: The checkpoint code in the containerd task.go file is executed!!")
+
+	// start := time.Now()
 	ctx, done, err := t.client.WithLease(ctx)
 	if err != nil {
 		return nil, err
 	}
+
+	// timeElapsed := time.Since(start)
+	// logrus.Debugf("FAAS: The lease time took %s seconds", timeElapsed)
+
 	defer done(ctx)
+
+	// start = time.Now()
+
 	cr, err := t.client.ContainerService().Get(ctx, t.id)
 	if err != nil {
 		return nil, err
 	}
 
+	// timeElapsed = time.Since(start)
+	// logrus.Debugf("FAAS: The fetching of container service took time %s seconds", timeElapsed)
+
+	// start = time.Now()
+
 	request := &tasks.CheckpointTaskRequest{
 		ContainerID: t.id,
 	}
+
 	i := CheckpointTaskInfo{
 		runtime: cr.Runtime.Name,
 	}
@@ -439,10 +457,17 @@ func (t *task) Checkpoint(ctx context.Context, opts ...CheckpointTaskOpts) (Imag
 			return nil, err
 		}
 	}
+
+	// timeElapsed = time.Since(start)
+	// logrus.Debugf("FAAS: The checkpoint task information took %s seconds", timeElapsed)
+
+	// start = time.Now()
+
 	// set a default name
 	if i.Name == "" {
 		i.Name = fmt.Sprintf(checkpointNameFormat, t.id, time.Now().Format(checkpointDateFormat))
 	}
+
 	request.ParentCheckpoint = i.ParentCheckpoint
 	if i.Options != nil {
 		any, err := typeurl.MarshalAny(i.Options)
@@ -451,20 +476,40 @@ func (t *task) Checkpoint(ctx context.Context, opts ...CheckpointTaskOpts) (Imag
 		}
 		request.Options = any
 	}
+
+	// timeElapsed = time.Since(start)
+	// logrus.Debugf("FAAS: The parent checkpoint information fetch took %s seconds", timeElapsed)
+
+	// start = time.Now()
+
 	// make sure we pause it and resume after all other filesystem operations are completed
 	if err := t.Pause(ctx); err != nil {
 		return nil, err
 	}
+
+	// timeElapsed = time.Since(start)
+	// logrus.Debugf("FAAS: The container pause took %s seconds", timeElapsed)
+
 	defer t.Resume(ctx)
+
+	start := time.Now()
+
 	index := v1.Index{
 		Versioned: is.Versioned{
 			SchemaVersion: 2,
 		},
 		Annotations: make(map[string]string),
 	}
+
 	if err := t.checkpointTask(ctx, &index, request); err != nil {
 		return nil, err
 	}
+
+	timeElapsed := time.Since(start)
+	logrus.Debugf("FAAS: The container checkpoint task took %s seconds", timeElapsed)
+
+	// start = time.Now()
+
 	// if checkpoint image path passed, jump checkpoint image,
 	// return an empty image
 	if isCheckpointPathExist(cr.Runtime.Name, i.Options) {
@@ -477,15 +522,32 @@ func (t *task) Checkpoint(ctx context.Context, opts ...CheckpointTaskOpts) (Imag
 		}
 		index.Annotations["image.name"] = cr.Image
 	}
+
+	// timeElapsed = time.Since(start)
+	// logrus.Debugf("FAAS: The container checkpoint image took %s seconds", timeElapsed)
+
+	// start = time.Now()
+
 	if cr.SnapshotKey != "" {
 		if err := t.checkpointRWSnapshot(ctx, &index, cr.Snapshotter, cr.SnapshotKey); err != nil {
 			return nil, err
 		}
 	}
+
+	// timeElapsed = time.Since(start)
+	// logrus.Debugf("FAAS: The container checkpoint RW snapshot took %s seconds", timeElapsed)
+
+	start = time.Now()
+	logrus.Debugf("FAAS: The container write index is %s", index)
 	desc, err := t.writeIndex(ctx, &index)
 	if err != nil {
 		return nil, err
 	}
+	logrus.Debugf("FAAS: The container write index result is %s", desc)
+	timeElapsed = time.Since(start)
+	logrus.Debugf("FAAS: The container write index took %s seconds", timeElapsed)
+
+	// start = time.Now()
 	im := images.Image{
 		Name:   i.Name,
 		Target: desc,
@@ -493,10 +555,16 @@ func (t *task) Checkpoint(ctx context.Context, opts ...CheckpointTaskOpts) (Imag
 			"containerd.io/checkpoint": "true",
 		},
 	}
+
 	if im, err = t.client.ImageService().Create(ctx, im); err != nil {
 		return nil, err
 	}
+	// timeElapsed = time.Since(start)
+	// logrus.Debugf("FAAS: The create image service took %s seconds", timeElapsed)
+	logrus.Debugf("FAAS: The containerd task.go is completed !!!!")
+
 	return NewImage(t.client, im), nil
+
 }
 
 // UpdateTaskInfo allows updated specific settings to be changed on a task
@@ -579,10 +647,14 @@ func (t *task) Metrics(ctx context.Context) (*types.Metric, error) {
 }
 
 func (t *task) checkpointTask(ctx context.Context, index *v1.Index, request *tasks.CheckpointTaskRequest) error {
+	logrus.Debugf("FAAS: The checkpoint task starts executing now.")
+	logrus.Debugf("FAAS: The type of the object is: %s\n", reflect.TypeOf(t.client.TaskService()))
+
 	response, err := t.client.TaskService().Checkpoint(ctx, request)
 	if err != nil {
 		return errdefs.FromGRPC(err)
 	}
+
 	// NOTE: response.Descriptors can be an empty slice if checkpoint image is jumped
 	// add the checkpoint descriptors to the index
 	for _, d := range response.Descriptors {
diff --git a/vendor/github.com/containerd/go-runc/runc.go b/vendor/github.com/containerd/go-runc/runc.go
index f5f03ae95e..b2a76ef49b 100644
--- a/vendor/github.com/containerd/go-runc/runc.go
+++ b/vendor/github.com/containerd/go-runc/runc.go
@@ -126,6 +126,7 @@ func (o *CreateOpts) args() (out []string, err error) {
 
 // Create creates a new container and returns its pid if it was created successfully
 func (r *Runc) Create(context context.Context, id, bundle string, opts *CreateOpts) error {
+
 	args := []string{"create", "--bundle", bundle}
 	if opts != nil {
 		oargs, err := opts.args()
@@ -515,6 +516,7 @@ func PreDump(args []string) []string {
 
 // Checkpoint allows you to checkpoint a container using criu
 func (r *Runc) Checkpoint(context context.Context, id string, opts *CheckpointOpts, actions ...CheckpointAction) error {
+	fmt.Errorf("FAAS: The go-runc checkpoint is executed!!")
 	args := []string{"checkpoint"}
 	extraFiles := []*os.File{}
 	if opts != nil {
